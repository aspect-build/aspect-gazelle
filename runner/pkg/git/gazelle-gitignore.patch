diff --git a/walk/config.go b/walk/config.go
index 53dcabe..b60bed5 100644
--- a/walk/config.go
+++ b/walk/config.go
@@ -58,6 +58,12 @@ type walkConfig struct {
 	ignore              bool
 	follow              []string
 	validBuildFileNames []string // to be copied to config.Config
+
+	// PATCH(gitignore) ---
+	isGitIgnoreDisabled bool
+	gitIgnoreData       interface{}
+	isGitIgnoredExt     func([]string, bool) bool
+	// END PATCH(gitignore) ---
 }
 
 const (
@@ -79,6 +85,18 @@ func (wc *walkConfig) clone() *walkConfig {
 	return &wcCopy
 }
 
+// PATCH(gitignore) ---
+func (wc *walkConfig) isGitIgnored(p string, isDir bool) bool {
+	if wc.isGitIgnoreDisabled {
+		return false
+	}
+	if wc.isGitIgnoredExt == nil {
+		return false
+	}
+	return wc.isGitIgnoredExt(strings.Split(p, "/"), isDir)
+	// END PATCH(gitignore) ---
+}
+
 func (wc *walkConfig) isExcludedDir(p string) bool {
 	return path.Base(p) == ".git" || wc.ignoreFilter.isDirectoryIgnored(p) || matchAnyGlob(wc.excludes, p)
 }
@@ -139,7 +157,8 @@ func (cr *Configurer) CheckFlags(_ *flag.FlagSet, c *config.Config) error {
 }
 
 func (*Configurer) KnownDirectives() []string {
-	return []string{"build_file_name", "generation_mode", "exclude", "follow", "ignore"}
+	// PATCH(gitignore) ---
+	return []string{"build_file_name", "generation_mode", "exclude", "follow", "ignore", "gitignore"}
 }
 
 func (cr *Configurer) Configure(c *config.Config, rel string, f *rule.File) {
@@ -196,6 +215,9 @@ func configureForWalk(parent *walkConfig, rel string, f *rule.File) *walkConfig
 					log.Printf("the ignore directive does not take any arguments. Did you mean to use gazelle:exclude instead? in //%s '# gazelle:ignore %s'", f.Pkg, d.Value)
 				}
 				wc.ignore = true
+			case "gitignore":
+				// PATCH(gitignore) ---
+				wc.isGitIgnoreDisabled = d.Value != "enabled"
 			}
 		}
 	}
diff --git a/walk/dirinfo.go b/walk/dirinfo.go
index d2f989b..d993a44 100644
--- a/walk/dirinfo.go
+++ b/walk/dirinfo.go
@@ -69,6 +69,24 @@ func (w *walker) loadDirInfo(rel string) (DirInfo, error) {
 	}
 
 	info.config = configureForWalk(parentConfig, rel, info.File)
+
+	// PATCH(gitignore) ---
+	if w.gitignoreProcessor != nil {
+		// Process any new .gitignore files
+		for _, entry := range entries {
+			if entry.Name() == ".gitignore" {
+				gitignorePath := rel
+				if gitignorePath != "" {
+					gitignorePath += "/"
+				}
+				gitignorePath += entry.Name()
+				info.config.isGitIgnoredExt, info.config.gitIgnoreData = w.gitignoreProcessor(w.rootConfig.RepoRoot, gitignorePath, parentConfig.gitIgnoreData)
+				break
+			}
+		}
+	}
+	// END-PATCH(gitignore) ---
+
 	if info.config.isExcludedDir(rel) {
 		// Build file excludes the current directory. Ignore contents.
 		entries = nil
@@ -77,6 +95,13 @@ func (w *walker) loadDirInfo(rel string) (DirInfo, error) {
 	for _, e := range entries {
 		entryRel := path.Join(rel, e.Name())
 		e = maybeResolveSymlink(info.config, dir, entryRel, e)
+
+		// PATCH(gitignore) ---
+		if info.config.isGitIgnored(entryRel, e.IsDir()) {
+			continue
+		}
+		// END-PATCH(gitignore) ---
+
 		if e.IsDir() && !info.config.isExcludedDir(entryRel) {
 			info.Subdirs = append(info.Subdirs, e.Name())
 		} else if !e.IsDir() && !info.config.isExcludedFile(entryRel) {
diff --git a/walk/walk.go b/walk/walk.go
index 0e59bcf..ae1f513 100644
--- a/walk/walk.go
+++ b/walk/walk.go
@@ -310,6 +310,10 @@ type walker struct {
 	// If the Config.Strict flag is set in the root configuration, we return
 	// quickly after the first error.
 	errs []error
+
+	// PATCH(gitignore) ---
+	gitignoreProcessor func(string, string, interface{}) (func([]string, bool) bool, interface{})
+	// END-PATCH(gitignore) ---
 }
 
 type visitInfo struct {
@@ -373,6 +377,12 @@ func newWalker(c *config.Config, cexts []config.Configurer, dirs []string, mode
 		relsToVisitSeen: make(map[string]struct{}),
 	}
 
+	// PATCH(gitignore) ---
+	if ext, hasExt := c.Exts["__aspect:gitignoreProcessor"]; hasExt {
+		w.gitignoreProcessor = ext.(func(string, string, interface{}) (func([]string, bool) bool, interface{}))
+	}
+	// END-PATCH(gitignore) ---
+
 	// Asynchronously populate the walker cache in the background.
 	go w.populateCache()
 
